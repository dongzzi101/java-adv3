
## 섹션 2. 람다가 필요한 이유

### 람다가 필요한 이유 1

* 좋은 코드 유지의 핵심은 **변하는 부분과 변하지 않는 부분의 분리**임
* 중복을 제거하고 유연하게 유지보수 가능한 코드를 작성할 수 있음

---

### 람다가 필요한 이유 2

* 값 데이터(String, int 등)\*\*를 메서드에 전달하는 건 간단함
* 하지만 코드 조각(동작)을 메서드에 전달하려면 인스턴스를 전달하고 그 인스턴스의 메서드를 호출해야 함

**동작 매개변수화**란?

| 구분       | 설명                                      |
| -------- | --------------------------------------- |
| 값 매개변수화  | 값(숫자, 문자열 등)을 바꿔가며 메서드의 동작을 다르게 함       |
| 동작 매개변수화 | 어떤 동작(로직)을 메서드에 전달함. 인스턴스 참조, 람다 등을 사용함 |

---

### 람다가 필요한 이유 3

* 자바에서 메서드의 인수로 전달할 수 있는 건 두 가지임

    1. 기본형 타입 (int, double 등)
    2. 참조형 타입 (인스턴스)

* 결국 메서드에 **동작을 전달하려면 객체로 포장해서 전달**해야 했음 → 이를 더 간결하게 하기 위해 람다 필요

---

### 함수 vs 메서드

| 구분       | 함수                  | 메서드                      |
| -------- | ------------------- | ------------------------ |
| 클래스와의 관계 | 클래스와 무관, 독립적        | 클래스 내부에 정의된 함수           |
| 호출 방식    | 객체 없이 호출            | 객체 또는 클래스 통해 호출          |
| 상태 접근    | 객체 상태 접근 불가         | 객체 상태(필드, 메서드) 접근 가능     |
| 사용 예시    | C, JavaScript의 함수 등 | Java, Python 클래스 내 메서드 등 |

**정리**

* 메서드는 클래스 내부의 함수로, 객체의 상태와 밀접한 관련 있음
* 함수는 독립적인 로직 단위로, 클래스 없이도 호출 가능함
* 따라서 함수와 메서드는 **기능은 비슷하지만 소속과 호출 방식이 다름**

---

### 람다 시작

* 기본 문법: `(매개변수) -> {본문}`
* 이름, 반환타입 생략 가능
* 익명 클래스보다 훨씬 간결하게 표현 가능
* 코드 조각을 전달하는 데 매우 유용함

---

## 섹션 3. 람다

### 람다 정의

* 자바 8부터 도입된 기능으로, 자바에서 함수형 프로그래밍을 지원하기 위해 만들어짐
* 익명 함수(이름 없는 함수)를 의미하며, `() -> {}` 형태로 사용
* 변수처럼 다룰 수 있으며, 실제로 클래스가 생성되고 인스턴스도 만들어짐

#### 용어 정리

| 용어  | 의미                                 |
| --- | ---------------------------------- |
| 람다  | 익명 함수 자체를 지칭하는 일반적인 표현             |
| 람다식 | 람다를 구현하는 구체적인 문법 표현 `(매개변수) -> {}` |

#### 요약

* 람다는 익명 클래스보다 코드가 간결하고 생산성이 높음
* 대부분의 익명 클래스는 람다로 대체 가능
* `new` 키워드 없이도 인스턴스가 생성됨

---

### 함수형 인터페이스

* 하나의 추상 메서드만 가진 인터페이스
* 람다는 오직 함수형 인터페이스에만 할당 가능
* 이런 인터페이스를 **SAM (Single Abstract Method)** 인터페이스라 부름
* 함수형 인터페이스임을 명시하려면 `@FunctionalInterface` 애노테이션 사용

### @FunctionalInterface

* 추상 메서드가 하나만 존재해야 함을 컴파일 타임에 보장
* 실수로 추상 메서드를 2개 이상 선언할 경우 컴파일 에러 발생

---

### 람다와 시그니처

* 람다가 할당되는 함수형 인터페이스의 추상 메서드 **시그니처**와 일치해야 함

#### 메서드 시그니처 구성 요소

1. 메서드 이름
2. 매개변수 수, 타입, 순서
3. 반환 타입

※ 람다에서 메서드 이름은 신경 쓰지 않아도 됨 (함수형 인터페이스에 따라 정해짐)

---

### 람다와 생략

#### 단일 표현식

* 단일 표현식인 경우, 중괄호 `{}`와 `return` 생략 가능
* 여러 문장이 포함된 경우 생략 불가능

#### 표현식이란?

* 하나의 값으로 평가되는 코드 조각
* 예: 산술식, 메서드 호출, 객체 생성 등
* 제어문(if, for 등), 메서드 선언 등은 표현식이 아님

#### 타입 생략 (타입 추론)

* 컴파일러가 함수형 인터페이스의 메서드 시그니처를 기반으로 타입을 자동 추론
* 매개변수 타입 생략 가능
* 반환 타입은 문법적으로 명시 불가 → 컴파일러가 항상 추론

#### 괄호 생략

* 매개변수가 1개일 경우 괄호 `()` 생략 가능

| 항목           | 생략 가능 여부        |
| ------------ | --------------- |
| 매개변수 타입      | 생략 가능           |
| 매개변수 괄호      | 1개일 경우 생략 가능    |
| 반환 타입        | 생략 필수 (컴파일러 추론) |
| 중괄호 & return | 단일 표현식이면 생략 가능  |

---

### 람다의 전달

* 람다는 변수, 메서드의 인자, 반환값으로 전달 가능
* 변수에 대입하면 람다 인스턴스의 참조값이 대입되는 것임

#### 전달 방식

| 전달 방식       | 설명                               |
| ----------- | -------------------------------- |
| 변수에 대입      | 함수형 인터페이스 타입 변수에 람다 인스턴스를 대입     |
| 메서드의 인자로 전달 | 메서드 호출 시 람다 인스턴스를 직접 전달 또는 변수 전달 |
| 메서드에서 람다 반환 | 메서드가 람다 인스턴스의 참조값을 반환            |

---

### 고차 함수

* **함수를 값처럼 다루는 함수**
* 다음 중 하나를 만족하면 고차 함수임

  * 함수를 인자로 받음
  * 함수를 반환함

### 자바에서의 고차 함수

* 자바에서는 함수(람다)를 직접 주고받을 수 없기 때문에 **함수형 인터페이스**를 사용해 우회함
* 결국 함수형 인터페이스를 구현한 객체를 주고받는 방식으로 고차 함수를 구현

### 용어 정리

| 용어          | 설명                               |
| ----------- | -------------------------------- |
| 일반 함수       | 값을 받아 값을 반환                      |
| 고차 함수       | 함수를 받아들이거나 함수를 반환                |
| 고차 함수 명칭 유래 | 값을 넘어서 함수 자체를 값처럼 다룬다는 추상화 수준 때문 |

---
